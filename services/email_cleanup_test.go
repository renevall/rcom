package services

import (
	"strings"
	"testing"
)

// These test were generated by using ChatGTP. Becase I had clear inputs and output
// I could tell the ai would be able to generate the tests for me. One key decision I made
// was to use io.Reader instead of os.File. This would allow me to use a string as input
// and not have to create a file for the tests. This would make the tests faster and easier to write.

// Also this test is relevant because initial implementation would return 49999 records instead of 50000 records.
// This test would have caught that bug.

func TestStreamFile(t *testing.T) {
	// Define test cases
	tests := []struct {
		name              string
		input             string
		batchSize         int
		wantBatches       int // Expected number of batches
		wantLastBatchSize int // Expected size of the last batch (if not full)
	}{
		{
			name:              "Exact multiple of batchSize",
			input:             "email1\nemail2\nemail3\nemail4\n",
			batchSize:         2,
			wantBatches:       2,
			wantLastBatchSize: 2, // Last batch is full
		},
		{
			name:              "Not a multiple of batchSize, has remainder",
			input:             "email1\nemail2\nemail3\n",
			batchSize:         2,
			wantBatches:       2,
			wantLastBatchSize: 1, // Last batch is not full
		},
		{
			name:              "Single line",
			input:             "email1\n",
			batchSize:         2,
			wantBatches:       1,
			wantLastBatchSize: 1,
		},
		{
			name:              "Empty input",
			input:             "",
			batchSize:         2,
			wantBatches:       0,
			wantLastBatchSize: 0,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			reader := strings.NewReader(tc.input)
			service := EmailCleanerService{} // Assuming EmailCleanerService can be instantiated without dependencies for this test

			outCh := service.StreamFile(reader, tc.batchSize)

			batchCount := 0
			lastBatchSize := 0
			for batch := range outCh {
				batchCount++
				lastBatchSize = len(batch)
			}

			if batchCount != tc.wantBatches {
				t.Errorf("got %d batches, want %d", batchCount, tc.wantBatches)
			}

			if lastBatchSize != tc.wantLastBatchSize {
				t.Errorf("last batch size = %d; want %d", lastBatchSize, tc.wantLastBatchSize)
			}
		})
	}
}
